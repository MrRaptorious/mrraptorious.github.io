import"../chunks/CWj6FrbW.js";import"../chunks/Be5dWuTk.js";import{o as W}from"../chunks/CbPKOLcE.js";import{p as k,d as T,f as H,t as q,a as J,e as K,j as Q,r as Y,n as Z}from"../chunks/CKsiWAQM.js";import{s as X}from"../chunks/n36DDGjf.js";import{i as $}from"../chunks/DRl7fnVc.js";import{L as ee,F as te,C as V,b as ne,G,B as U,c as j,d as P,e as N,f as C,g as ie,h as B,i as A,M as S,j as L,S as se,P as oe,W as re,k as ae,l as le,a as ce,A as he,m as ue}from"../chunks/CubGkJgd.js";import"../chunks/DkrqlFHz.js";const de={title:"Spinnable Badge"},me=`uniform vec3 diffuse;
uniform vec3 lightPosition;  // NEU: Position des Lichts im Weltraum
uniform vec3 lightColor;
uniform vec3 ambientColor;
uniform float ambientIntensity;
uniform float lightRadius;   // NEU: Radius/Einflussbereich des Lichts für den Falloff (optional)

varying vec3 vNormal;
varying vec3 vWorldPosition; // Weltposition des Fragments

void main() {
    vec3 normal = normalize(vNormal);

    // --- 1. Ambient Light Komponente ---
    vec3 ambientLight = ambientColor * ambientIntensity;

    // --- 2. Diffuse Light Komponente (Point Light) ---
    // Richtung vom Fragment zum Lichtpunkt
    vec3 lightDirectionToFragment = normalize(lightPosition - vWorldPosition);

    // Distanz vom Fragment zum Lichtpunkt
    float distance = length(lightPosition - vWorldPosition);

    // Lambert'sches Cosinus-Gesetz (diffuse Komponente)
    // Wir nutzen hier \`lightDirectionToFragment\`, da sie VOM Licht zum Fragment zeigt.
    // Wenn \`normal\` nach außen zeigt, wollen wir den Winkel zur entgegen gesetzten Richtung der Lichtquelle.
    // Oder, wir nutzen den Vektor VOM Fragment ZUM Licht und dotten ihn mit der Normalen.
    // Hier ist es \`dot(normal, lightDirectionToFragment)\`, weil \`lightDirectionToFragment\`
    // die Richtung ist, in die das Licht STRAHLT (aus Sicht des Fragments).
    float NdotL = max(dot(normal, lightDirectionToFragment), 0.0);

    // Licht-Abschwächung (Falloff/Attenuation)
    // Ein gängiges quadratisches Falloff-Modell: 1.0 / (a + b*d + c*d*d)
    // Für einen einfacheren, aber effektiven Falloff, können wir auch einen Radius nutzen:
    // Der LightRadius bestimmt, wie weit das Licht wirkt und wie schnell es abnimmt.
    float attenuation = 1.0 / (1.0 + (distance * distance) / (lightRadius * lightRadius));
    // Oder ein einfaches inverses Quadrat:
    // float attenuation = 1.0 / (distance * distance + 0.0001); // 0.0001 um Division durch Null zu vermeiden

    // Kombiniere NdotL mit der Abschwächung
    float directLightIntensity = NdotL * attenuation;

    vec3 diffuseLight = diffuse * lightColor * directLightIntensity;

    // --- 3. Endgültige Farbe ---
    vec3 finalColor = ambientLight + diffuseLight;
    finalColor = clamp(finalColor, 0.0, 1.0);

    gl_FragColor = vec4(finalColor, 1.0);
}`,fe=`varying vec3 vNormal; // NEU: Normale im Weltraum
varying vec3 vWorldPosition; 

void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    vNormal = normalize(normalMatrix * normal);
}`,pe=/^[og]\s*(.+)?/,ge=/^mtllib /,ve=/^usemtl /,be=/^usemap /,D=/\s+/,R=new L,I=new L,E=new L,O=new L,y=new L,M=new V;function we(){const z={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(n,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=n,this.object.fromDeclaration=e!==!1;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:n||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,i){const a=this._finalize(!1);a&&(a.inherited||a.groupCount<=0)&&this.materials.splice(a.index,1);const m={index:this.materials.length,name:t||"",mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:a!==void 0?a.smooth:this.smooth,groupStart:a!==void 0?a.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(g){const r={index:typeof g=="number"?g:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return r.clone=this.clone.bind(r),r}};return this.materials.push(m),m},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const i=this.currentMaterial();if(i&&i.groupEnd===-1&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),t&&this.materials.length>1)for(let a=this.materials.length-1;a>=0;a--)this.materials[a].groupCount<=0&&this.materials.splice(a,1);return t&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),i}},s&&s.name&&typeof s.clone=="function"){const t=s.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(n,e){const s=parseInt(n,10);return(s>=0?s-1:s+e/3)*3},parseNormalIndex:function(n,e){const s=parseInt(n,10);return(s>=0?s-1:s+e/3)*3},parseUVIndex:function(n,e){const s=parseInt(n,10);return(s>=0?s-1:s+e/2)*2},addVertex:function(n,e,s){const t=this.vertices,i=this.object.geometry.vertices;i.push(t[n+0],t[n+1],t[n+2]),i.push(t[e+0],t[e+1],t[e+2]),i.push(t[s+0],t[s+1],t[s+2])},addVertexPoint:function(n){const e=this.vertices;this.object.geometry.vertices.push(e[n+0],e[n+1],e[n+2])},addVertexLine:function(n){const e=this.vertices;this.object.geometry.vertices.push(e[n+0],e[n+1],e[n+2])},addNormal:function(n,e,s){const t=this.normals,i=this.object.geometry.normals;i.push(t[n+0],t[n+1],t[n+2]),i.push(t[e+0],t[e+1],t[e+2]),i.push(t[s+0],t[s+1],t[s+2])},addFaceNormal:function(n,e,s){const t=this.vertices,i=this.object.geometry.normals;R.fromArray(t,n),I.fromArray(t,e),E.fromArray(t,s),y.subVectors(E,I),O.subVectors(R,I),y.cross(O),y.normalize(),i.push(y.x,y.y,y.z),i.push(y.x,y.y,y.z),i.push(y.x,y.y,y.z)},addColor:function(n,e,s){const t=this.colors,i=this.object.geometry.colors;t[n]!==void 0&&i.push(t[n+0],t[n+1],t[n+2]),t[e]!==void 0&&i.push(t[e+0],t[e+1],t[e+2]),t[s]!==void 0&&i.push(t[s+0],t[s+1],t[s+2])},addUV:function(n,e,s){const t=this.uvs,i=this.object.geometry.uvs;i.push(t[n+0],t[n+1]),i.push(t[e+0],t[e+1]),i.push(t[s+0],t[s+1])},addDefaultUV:function(){const n=this.object.geometry.uvs;n.push(0,0),n.push(0,0),n.push(0,0)},addUVLine:function(n){const e=this.uvs;this.object.geometry.uvs.push(e[n+0],e[n+1])},addFace:function(n,e,s,t,i,a,m,g,r){const f=this.vertices.length;let o=this.parseVertexIndex(n,f),c=this.parseVertexIndex(e,f),l=this.parseVertexIndex(s,f);if(this.addVertex(o,c,l),this.addColor(o,c,l),m!==void 0&&m!==""){const p=this.normals.length;o=this.parseNormalIndex(m,p),c=this.parseNormalIndex(g,p),l=this.parseNormalIndex(r,p),this.addNormal(o,c,l)}else this.addFaceNormal(o,c,l);if(t!==void 0&&t!==""){const p=this.uvs.length;o=this.parseUVIndex(t,p),c=this.parseUVIndex(i,p),l=this.parseUVIndex(a,p),this.addUV(o,c,l),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(n){this.object.geometry.type="Points";const e=this.vertices.length;for(let s=0,t=n.length;s<t;s++){const i=this.parseVertexIndex(n[s],e);this.addVertexPoint(i),this.addColor(i)}},addLineGeometry:function(n,e){this.object.geometry.type="Line";const s=this.vertices.length,t=this.uvs.length;for(let i=0,a=n.length;i<a;i++)this.addVertexLine(this.parseVertexIndex(n[i],s));for(let i=0,a=e.length;i<a;i++)this.addUVLine(this.parseUVIndex(e[i],t))}};return z.startObject("",!1),z}class ye extends ee{constructor(n){super(n),this.materials=null}load(n,e,s,t){const i=this,a=new te(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(n,function(m){try{e(i.parse(m))}catch(g){t?t(g):console.error(g),i.manager.itemError(n)}},s,t)}setMaterials(n){return this.materials=n,this}parse(n){const e=new we;n.indexOf(`\r
`)!==-1&&(n=n.replace(/\r\n/g,`
`)),n.indexOf(`\\
`)!==-1&&(n=n.replace(/\\\n/g,""));const s=n.split(`
`);let t=[];for(let m=0,g=s.length;m<g;m++){const r=s[m].trimStart();if(r.length===0)continue;const f=r.charAt(0);if(f!=="#")if(f==="v"){const o=r.split(D);switch(o[0]){case"v":e.vertices.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3])),o.length>=7?(M.setRGB(parseFloat(o[4]),parseFloat(o[5]),parseFloat(o[6]),ne),e.colors.push(M.r,M.g,M.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]));break;case"vt":e.uvs.push(parseFloat(o[1]),parseFloat(o[2]));break}}else if(f==="f"){const c=r.slice(1).trim().split(D),l=[];for(let u=0,d=c.length;u<d;u++){const v=c[u];if(v.length>0){const b=v.split("/");l.push(b)}}const p=l[0];for(let u=1,d=l.length-1;u<d;u++){const v=l[u],b=l[u+1];e.addFace(p[0],v[0],b[0],p[1],v[1],b[1],p[2],v[2],b[2])}}else if(f==="l"){const o=r.substring(1).trim().split(" ");let c=[];const l=[];if(r.indexOf("/")===-1)c=o;else for(let p=0,u=o.length;p<u;p++){const d=o[p].split("/");d[0]!==""&&c.push(d[0]),d[1]!==""&&l.push(d[1])}e.addLineGeometry(c,l)}else if(f==="p"){const c=r.slice(1).trim().split(" ");e.addPointGeometry(c)}else if((t=pe.exec(r))!==null){const o=(" "+t[0].slice(1).trim()).slice(1);e.startObject(o)}else if(ve.test(r))e.object.startMaterial(r.substring(7).trim(),e.materialLibraries);else if(ge.test(r))e.materialLibraries.push(r.substring(7).trim());else if(be.test(r))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(f==="s"){if(t=r.split(" "),t.length>1){const c=t[1].trim().toLowerCase();e.object.smooth=c!=="0"&&c!=="off"}else e.object.smooth=!0;const o=e.object.currentMaterial();o&&(o.smooth=e.object.smooth)}else{if(r==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+r+'"')}}e.finalize();const i=new G;if(i.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let m=0,g=e.objects.length;m<g;m++){const r=e.objects[m],f=r.geometry,o=r.materials,c=f.type==="Line",l=f.type==="Points";let p=!1;if(f.vertices.length===0)continue;const u=new U;u.setAttribute("position",new j(f.vertices,3)),f.normals.length>0&&u.setAttribute("normal",new j(f.normals,3)),f.colors.length>0&&(p=!0,u.setAttribute("color",new j(f.colors,3))),f.hasUVIndices===!0&&u.setAttribute("uv",new j(f.uvs,2));const d=[];for(let b=0,_=o.length;b<_;b++){const x=o[b],F=x.name+"_"+x.smooth+"_"+p;let h=e.materials[F];if(this.materials!==null){if(h=this.materials.create(x.name),c&&h&&!(h instanceof P)){const w=new P;N.prototype.copy.call(w,h),w.color.copy(h.color),h=w}else if(l&&h&&!(h instanceof C)){const w=new C({size:10,sizeAttenuation:!1});N.prototype.copy.call(w,h),w.color.copy(h.color),w.map=h.map,h=w}}h===void 0&&(c?h=new P:l?h=new C({size:1,sizeAttenuation:!1}):h=new ie,h.name=x.name,h.flatShading=!x.smooth,h.vertexColors=p,e.materials[F]=h),d.push(h)}let v;if(d.length>1){for(let b=0,_=o.length;b<_;b++){const x=o[b];u.addGroup(x.groupStart,x.groupCount,b)}c?v=new B(u,d):l?v=new A(u,d):v=new S(u,d)}else c?v=new B(u,d[0]):l?v=new A(u,d[0]):v=new S(u,d[0]);v.name=r.name,i.add(v)}else if(e.vertices.length>0){const m=new C({size:1,sizeAttenuation:!1}),g=new U;g.setAttribute("position",new j(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(g.setAttribute("color",new j(e.colors,3)),m.vertexColors=!0);const r=new A(g,m);i.add(r)}return i}}const xe=""+new URL("../assets/card.D219hczd.obj",import.meta.url).href;var Le=T('<h1 class="text-4xl"> </h1> <canvas id="canvas" width="1000" height="1000"></canvas>',1);function Ae(z,n){k(n,!1),W(async()=>{{let u=function(){l&&l.rotateY(.005),g.render(a,m)};const i=window.document.getElementById("canvas"),a=new se,m=new oe(75,i.width/i.height,.1,1e3),g=new re({canvas:i});g.setSize(i.width,i.height),g.setAnimationLoop(u);const r=new ae(.1,16,16),f=new le({color:16776960}),o=new S(r,f);o.position.set(2,0,2,5),a.add(o);const c=new ce({uniforms:{diffuse:{value:new V(1,1,1)},lightPosition:{value:o.position},lightColor:{value:new V(1,1,1)},ambientColor:{value:new V(.5,.5,.5)},ambientIntensity:{value:.1},lightRadius:{value:5}},vertexShader:fe,fragmentShader:me});c.uniforms.diffuse.value=new V(0,1,0);let l;new ye().load(xe,function(d){l=new G,d.traverse(function(F){if(F.isMesh){const h=F;h.material=c,h.geometry.computeBoundingBox();const w=h.geometry.boundingBox.getCenter(new L);h.geometry.translate(-w.x,-w.y,-w.z)}}),l.add(d);const v=new he(5);l.add(v),a.add(l);const x=new ue().setFromObject(l,!0).getSize(new L).length()*.75;m.position.z=x,m.lookAt(0,0,0)},function(d){console.log(d.loaded/d.total*100+"% loaded")},function(d){console.error("An error happened while loading the OBJ:",d)}),u()}}),$();var e=Le(),s=H(e),t=Q(s,!0);Y(s),Z(2),q(()=>X(t,de.title)),J(z,e),K()}export{Ae as component};
